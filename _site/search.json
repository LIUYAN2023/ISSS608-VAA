[
  {
    "objectID": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html",
    "href": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html",
    "title": "Take-home_Ex02",
    "section": "",
    "text": "The country of Oceanus has requested the assistance of FishEye International in identifying companies that may be involved in illegal, unreported, and unregulated (IUU) fishing. As part of this collaboration, FishEye’s analysts have been provided with import/export data related to Oceanus’ marine and fishing industries.\nTo facilitate their analysis, FishEye has transformed the trade data into a knowledge graph. During their analysis, FishEye analysts have found that node-link diagrams provide a valuable high-level overview of the knowledge graph. However, they are now seeking visualizations that offer more detailed insights into patterns involving entities within the knowledge graph.\n\nBased on FishEye’s previous experiences, they are aware that companies engaged in illegal fishing tend to cease their operations temporarily but often resume their activities under different names.\nThe objective of this exercise is to compare the activities of these companies over time and identify any indications of their potential return to illicit practices.\nThis exercise source is from: Mini-Challenge 2 task 1"
  },
  {
    "objectID": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#install-r-packages-and-import-dataset",
    "href": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#install-r-packages-and-import-dataset",
    "title": "Take-home_Ex02",
    "section": "2.1 Install R Packages and Import Dataset",
    "text": "2.1 Install R Packages and Import Dataset\nThe code chunk below uses pacman::p_load() to check if packages are installed. If they are, they will be launched into R. The packages installed are:\n\n\nshow the code\npacman::p_load(jsonlite, tidygraph, ggraph, visNetwork, lubridate, tidyverse,readxl)\n\n\njsonlite: A simple and robust JSON parser and generator for R.\ntidygraph: this package provides a tidy API for graph/network manipulation.\nggraph: ggiraph is a tool that allows you to create dynamic ggplot graphs.\nvisNetwork: an R package for network visualization, using vis.js javascript library.\nlubridate: an R package that makes it easier to work with dates and times.\ntidyverse: A collection of core packages designed for data science, used extensively for data preparation and wrangling.\nreadxl：An R package makes it easy to get data out of Excel and into R.\nAll packages can be found within CRAN."
  },
  {
    "objectID": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#data-introduction",
    "href": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#data-introduction",
    "title": "Take-home_Ex02",
    "section": "2.2 Data Introduction",
    "text": "2.2 Data Introduction\nIn the code chunk below, fromJSON() of jsonlite package is used to import mc2_challenge_graph.json into R environment.\n\n\nshow the code\nmc2_data <- fromJSON(\"data/mc2_challenge_graph.json\")\n\n\nFor the purpose of this study, a directed multi-graph is provided. There are totally 34552 nodes and 5464092 directed edges.\nNode Attributes:\nid – Name of the company that originated (or received) the shipment.\nshpcountry – Country the company most often associated with when shipping.\nrcvcountry – Country the company most often associated with when receiving.\ndataset – Always ‘MC2’.\nEdge Attributes:\narrivaldate – Date the shipment arrived at port in YYYY-MM-DD format.\nhscode – Harmonized System code for the shipment. Can be joined with the hscodes table to get additional details.\nvalueofgoods_omu– Customs-declared value of the total shipment, in Oceanus Monetary Units (OMU).\nvolumeteu– The volume of the shipment in ‘Twenty-foot equivalent units’, roughly how many 20-foot standard containers would be required. (Actual number of containers may have been different as there are 20ft and 40ft standard containers and tankers that do not use containers)\nweightkg– The weight of the shipment in kilograms (if known).\ndataset– Always ‘MC2’.\ntype– Always ‘shipment’ for MC2.\ngenerated_by – Name of the program that generated the edge. (Only found on ‘bundle’ records.)\nNote: Some data provided by Oceanus was anonymized leading to some shipper and receiver names/countries being omitted. These are represented by numerical names in the graph."
  },
  {
    "objectID": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#data-wrangling",
    "href": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#data-wrangling",
    "title": "Take-home_Ex02",
    "section": "2.3 Data Wrangling",
    "text": "2.3 Data Wrangling\n\n2.3.1 Extract Nodes & Edges\nExtracting nodes : involves creating a tibble data frame called mc2_nodes from the mc2_data list object by using the select() function, which serves two purposes: selecting the required fields and re-organise the sequence of the fields.\n\n\nshow the code\nmc2_nodes <- as_tibble(mc2_data$nodes) %>%\n  select(id, shpcountry, rcvcountry)\n\n\nExtracting Edges: The code chunk is used to extract edges data table from mc2_data list object and save the output in a tibble data frame object called mc2_edges.\n\n\nshow the code\nmc2_edges <- as_tibble(mc2_data$links) %>%\n  mutate(ArrivalDate = ymd(arrivaldate)) %>%\n  mutate(Year = year(ArrivalDate)) %>%\n  select(source, target, ArrivalDate, Year, hscode, valueofgoods_omu, \n         volumeteu, weightkg, valueofgoodsusd) %>% \n  distinct()\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nmutate() is used two times to create two derive fields.\n\nymd() of lubridate package is used to covert arrivaldate field from character data type into date data type.\nyear() of lubridate package is used to convert the values in ArrivalDate field into year values.\n\nselect() is used not only to select the field needed but also to re-organise the sequent of the fields.\n\n\n\n\n\n2.3.2 Data Preparation _ HScode\nThe Harmonized System is a standardized numerical method of classifying traded products. It is used by customs authorities around the world to identify products when assessing duties and taxes and for gathering statistics.\nIn the original dataframe, there are numerous HScodes that are unrelated to “Fishing”. To filter out observations specifically related to fishing, we utilize the grep function to select only those HScodes that begin with 301-308.\n\n\nshow the code\n# filters the dataframe mc2_edges hscode start with 301-308\nmc2_edges <- mc2_edges[grep(\"^30[1-8]\", mc2_edges$hscode), ]\n\n# Count each hscode frequency\nhscode_counts <- table(mc2_edges$hscode)\n\n# Sort by count from highest to lowest\nhscode_counts_sorted <- sort(hscode_counts, decreasing = TRUE)\n\n# Create a dataframe containing hscode and count\nhscode_counts_df <- data.frame(hscode = names(hscode_counts_sorted), count = hscode_counts_sorted, stringsAsFactors = FALSE)\n\n\nAfter the compilation of the hscode_counts_df, it is important to determine the meaning of the HScode. Therefore, we proceed by reading the HScode list and employing the left_join function to establish a linkage between the item description and the hscode_counts_df data frame.\n\n\nshow the code\n# Remove the last zero in hscode\nhscode_counts_df$hscode <- sub(\"0$\", \"\", hscode_counts_df$hscode)\n\n# R an Excel file \"HScode\"\nHScode_list <- read_excel(\"data/HScode.xlsx\", sheet = 1)\n\n# Change the HS Code data type\nHScode_list$`HS Code` <- as.character(HScode_list$`HS Code`)\n\n# hscode_counts_df left join HScode_list to improt the HScode description\nmerged_data <- left_join(hscode_counts_df, select(HScode_list, -S.No.), by = c(\"hscode\" = \"HS Code\"))\n\n\nWe have summarized the top 6 most frequently occurring HScodes in the dataframe, along with their corresponding fish types based on the HScode descriptions. These HScodes and their associated fish types will serve as the starting point for our research.\n\nTop Frequency HScode\n\n\nHScode\nCount\nFish Type\n\n\n\n\n306170\n156204\nOther shrimps and prawns\n\n\n304620\n87340\nCatfish\n\n\n304610\n36615\nTilapias\n\n\n304710\n27231\nCod\n\n\n304750\n23926\nAlaska Pollack\n\n\n304810\n21433\nPacific salmonAtlantic salmon and Danube salmon\n\n\n\nThe HScode serves as an indicator of the product variety within each company. To analyze this, we have introduced a new variable called “HScode_type” that tallies the number of unique HScode values found in all transaction records for each company (node).\n\n\nshow the code\n# Create transitional dataframe to record all the company and corresponding Year\ntransition_data_HScode <- data.frame(\n  company = c(mc2_edges$source, mc2_edges$target),\n  HScode = c(mc2_edges$hscode, mc2_edges$ hscode)\n)\n\n# Aggregating companies & count each company's running year and running_ year_ Category\naggregate_data_HScode <- transition_data_HScode %>%\n  group_by(company) %>%\n  mutate(HScode_type = n_distinct(HScode)) %>%\n  distinct(company, HScode_type)%>%\n  mutate(HScode_category = cut(HScode_type, breaks = c(-Inf, 1, Inf), labels = c(\"<=1\",\">1\")))\n  \n# Filter the data \nfiltered_data <- subset(aggregate_data_HScode, HScode_type < 10)\n\n# Plot the histogram\nggplot(filtered_data, aes(x = HScode_type)) +\n  geom_histogram(binwidth = 1, fill = \"blue\", color = \"black\") +\n  labs(x = \"HScode_type\", y = \"Frequency\", title = \"Histogram of HScode_type (<10, binwidth = 1)\")\n\n\n\n\n\nIn order to gain a holistic understanding of the distribution of companies with different product varieties, we have generated a histogram depicting the frequency of HScode_type values below 10. Upon examining the histogram, we observe a substantial proportion of companies having an HScode_type value of 1 compared to other HScode_type values.\nTo further categorize the companies based on their product variety, we have introduced a new categorical variable named “HScode_category.” This variable assigns a label to each node, differentiating between HScode_type values less than or equal to 1 and those greater than 1. HScode_type <= 1 indicate companies with a narrow focus, specializing in a specific fish type. Conversely, HScode_type >1 indicates companies with a relatively diverse range of products.\n\n\n2.3.3 Data Preparation _ Running Year Category\nIn light of the circumstance where companies engaged in illegal fishing activities might cease operations but subsequently resume their activities under a different corporate identity, it is noteworthy that companies with shorter running years possess a higher likelihood of engaging in illicit behaviors.so we create transition_data to count each company’s running years.\n\n\nshow the code\n# Create transitional dataframe to record all the company and corresponding Year\ntransition_data_Year <- data.frame(\n  company = c(mc2_edges$source, mc2_edges$target),\n  Year = c(mc2_edges$Year, mc2_edges$Year)\n)\n\n# Aggregating companies & count each company's running year and running_ year_ Category\naggregate_data_Year <- transition_data_Year %>%\n  group_by(company) %>%\n  mutate(running_year = n_distinct(Year)) %>%\n  distinct(company, running_year) %>%\n  mutate(running_year_category = cut(running_year, breaks = c(-Inf, 2, Inf), labels = c(\"<=2\",\">2\")))\n\n\nTo facilitate analysis, we have categorized the running years into distinct intervals, namely “<=2” and “>2”, to assess the stability of the companies. Within these intervals:\n\n“<=2” category represents companies with lower stability\n“>2” years category signifies a relatively high level of stability.\n\nIt is worth noting that companies with lower stability, falling within the “<=2” category, tend to exhibit a higher likelihood of being associated with suspected illegal activities.\n\n\nshow the code\nlibrary(ggplot2)\n\n# Create a barchart of running_year distribution with adjusted x-axis labels\nggplot(aggregate_data_Year, aes(x = running_year)) +\n  geom_bar(fill = '#808de8') +\n  labs(x = \"Running Year\", y = \"Count\") +\n  ggtitle(\"Distribution of Running Year\") +\n  scale_x_continuous(breaks = 1:7, labels = 1:7) +\n  theme(axis.title.y = element_text(angle = 0),\n        axis.ticks.x = element_blank(),\n        panel.background = element_blank(),\n        axis.line = element_line(color = 'bisque3'),\n        plot.subtitle = element_text(color = \"dimgrey\", size = 12, face = \"bold\", hjust = 0.5))\n\n\n\n\n\nThe barchart depicting the “Distribution of Running Year” reveals a notable observation:\n\nA considerable proportion of companies, exceeding 4000 in number, have a running year of merely one year.\nAs the running year increases, there is a gradual decline in the number of companies.\nHowever, it is intriguing to note that there exists a substantial count of over 1000 companies that have been operating for seven years, surpassing the counts of companies with three, four, five, and six running years.\n\n\n\n2.3.4 Data Preparation _ Betweenness/In-degree/Out-degree\nCentrality is a significant characteristic in network analysis. In this section, we will compute three important centrality measures for each node: betweenness centrality, in-degree centrality, and out-degree centrality.\nBetweenness centrality: This measure quantifies the extent to which a node acts as a bridge or mediator in the network. It calculates the fraction of shortest paths between all pairs of nodes that pass through a particular node.\nIn-degree centrality: This measure focuses on the number of incoming edges or connections to a node. It signifies the degree to which a node receives interactions or dependencies from other nodes in the network.\nOut-degree centrality: This measure pertains to the number of outgoing edges or connections from a node. It indicates the degree to which a node initiates interactions or dependencies with other nodes in the network.\nThrough the computation of these centrality measures, we can gain insights into the structural importance and influence of each node within the network, enabling us to better understand the dynamics and functioning of the network as a whole.\n\n\nshow the code\n#install.packages(\"igraph\")  # Install the 'igraph' package\nlibrary(igraph)             # Load the 'igraph' package\n\n# Aggregating edges data\nmc2_all_edges_aggregated <- mc2_edges %>%\n  group_by(from = source, to = target, hscode, Year) %>%\n  summarise(weights = n()) %>%\n  filter(from != to) %>%\n  filter(weights > 20) %>%\n  ungroup()\n\n# Extracting unique node IDs\nid1_all <- mc2_all_edges_aggregated %>%\n  select(from) %>%\n  rename(id = from)\nid2_all <- mc2_all_edges_aggregated %>%\n  select(to) %>%\n  rename(id = to)\nmc2_all_nodes_extracted <- rbind(id1_all, id2_all) %>%\n  distinct()\n\nmc2_all_graph <- tbl_graph(nodes = mc2_all_nodes_extracted,\n                       edges = mc2_all_edges_aggregated,\n                       directed = TRUE)\n\n\n# Calculate betweenness centrality\nbetweenness_centrality <- betweenness(mc2_all_graph)\n\n# Calculate in-degree centrality\nin_degree_centrality <- degree(mc2_all_graph, mode = \"in\")\n\n# Calculate out-degree centrality\nout_degree_centrality <- degree(mc2_all_graph, mode = \"out\")\n\n# Convert the node attributes and ID to a dataframe\nnode_data <- data.frame(\n  ID = V(mc2_all_graph)$id,\n  Betweenness = betweenness_centrality,\n  In_Degree = in_degree_centrality,\n  Out_Degree = out_degree_centrality\n)\n\n\nBased on the node centrality table, we can classify the nodes into three distinct groups: Wholesaler: Nodes exhibiting non-zero values in betweenness centrality, in-degree centrality, and out-degree centrality. These nodes demonstrate a comprehensive pattern of connectivity within the network, indicating their involvement in multiple fish trading flows. We can infer that these nodes operate as wholesalers, facilitating the buying and selling of fish products. Buyer: Nodes displaying non-zero values in in-degree centrality, while both betweenness centrality and out-degree centrality possess zero values. These nodes primarily act as recipients or buyers within the network, buying fish products from other nodes. Supplier: Nodes featuring non-zero values in out-degree centrality, while both betweenness centrality and in-degree centrality exhibit zero values. These nodes operate as suppliers within the network, selling fish product to other nodes.\n\n\nshow the code\nnode_data$company_label <- NA  # Create a new column for storing company_ Label\n\n# Assign values to company_label based on conditions\nnode_data$company_label[node_data$Betweenness != 0 & node_data$Betweenness > 20] <- \"wholesaler_high\"\nnode_data$company_label[node_data$Betweenness != 0 & node_data$Betweenness <= 20 & node_data$Betweenness >= 10] <- \"wholesaler_medium\"\nnode_data$company_label[node_data$Betweenness != 0 & node_data$Betweenness < 10] <- \"wholesaler_low\"\n\nnode_data$company_label[node_data$Betweenness == 0 & node_data$Out_Degree == 0 & node_data$In_Degree != 0 & node_data$In_Degree > 150] <- \"buyer_high\"\nnode_data$company_label[node_data$Betweenness == 0 & node_data$Out_Degree == 0 & node_data$In_Degree != 0 & node_data$In_Degree <= 150 & node_data$In_Degree >= 50] <- \"buyer_mediu m\"\nnode_data$company_label[node_data$Betweenness == 0 & node_data$Out_Degree == 0 & node_data$In_Degree != 0 & node_data$In_Degree < 50] <- \"buyer_low\"\n\nnode_data$company_label[node_data$Betweenness == 0 & node_data$In_Degree == 0 & node_data$Out_Degree != 0 & node_data$Out_Degree > 50] <- \"supplier_high\"\nnode_data$company_label[node_data$Betweenness == 0 & node_data$In_Degree == 0 & node_data$Out_Degree != 0 & node_data$Out_Degree <= 50 & node_data$Out_Degree >= 20] <- \"supplier_medium\"\nnode_data$company_label[node_data$Betweenness == 0 & node_data$In_Degree == 0 & node_data$Out_Degree != 0 & node_data$Out_Degree < 20] <- \"supplier_low\"\n\n\n# Calculate the normalization of Betweenness, In_Degree, and Out_Degree\nnormalized_betweenness <- (node_data$Betweenness - min(node_data$Betweenness)) / (max(node_data$Betweenness) - min(node_data$Betweenness))\nnormalized_in_degree <- (node_data$In_Degree - min(node_data$In_Degree)) / (max(node_data$In_Degree) - min(node_data$In_Degree))\nnormalized_out_degree <- (node_data$Out_Degree - min(node_data$Out_Degree)) / (max(node_data$Out_Degree) - min(node_data$Out_Degree))\n\n# Add the 'size' column based on conditions\nnode_data$size_all <- ifelse(node_data$Betweenness != 0, normalized_betweenness,\n                         ifelse(node_data$Out_Degree != 0, normalized_out_degree,\n                                ifelse(node_data$In_Degree != 0, normalized_in_degree, NA)))\n\n# Add the 'size' column based on conditions\nnode_data$company_category <- ifelse(node_data$Betweenness != 0, \"Wholesaler\",\n                         ifelse(node_data$Out_Degree != 0, \"Supplier\",\n                                ifelse(node_data$In_Degree != 0,\"Buyer\", NA)))\n#glimpse(node_data)\n\n\nTo comprehend the range of centrality within each model, we further divide the nodes into high, medium, and low levels based on their centrality scores, and subsequently generate box plots to visualize the distribution of centrality scores within each group.\n\n\nshow the code\nlibrary(ggplot2)\n\n# Create a custom color vector\ncolors <- c(\"#FF6F61\", \"#6B5B95\", \"#88B04B\", \"#F7CAC9\", \"#92A8D1\", \"#955251\", \"#B565A7\", \"#009B77\", \"#DD4124\")\n\n# Extract the required data\nboxplot_data <- node_data %>%\n  select(company_label, Betweenness, In_Degree, Out_Degree) %>%\n  pivot_longer(cols = -company_label, names_to = \"variable\", values_to = \"value\")\n\n# Plot the boxplot\nboxplot_plot <- ggplot(boxplot_data, aes(x = company_label, y = value, fill = company_label)) +\n  geom_boxplot() +\n  facet_wrap(~ variable, scales = \"free_y\", ncol = 1) +\n  theme_minimal() +\n  labs(x = \"company_label\", y = \"\") +\n  coord_flip() +\n  scale_fill_manual(values = colors)\n\nboxplot_plot\n\n\n\n\n\nFrom the boxplot analysis, the following observations can be made:\n- Only nodes categorized as wholesalers exhibit non-zero values in betweenness centrality. The range of betweenness centrality scores for wholesalers falls between [minimum value] and [maximum value].\n- Nodes categorized as suppliers have a zero in-degree centrality. Nodes categorized as buyers have a higher in-degree centrality compared to wholesalers within the same level. For instance, the in-degree centrality range for high-level buyers is from [minimum value] to [maximum value], whereas the in-degree centrality range for high-level wholesalers is from [minimum value] to [maximum value].\n- Nodes categorized as buyers have a zero in-degree centrality. Nodes categorized as suppliers have a higher out-degree centrality compared to wholesalers within the same level. For example, the out-degree centrality range for high-level suppliers is from [minimum value] to [maximum value], whereas the out-degree centrality range for high-level wholesalers is from [minimum value] to [maximum value].\nFor the subsequent analysis, we will simplify the node categorization into three basic models: wholesalers, buyers, and suppliers, in order to avoid excessive grouping and maintain focus on the fundamental classification.\n\n\n2.3.5 Data Preparation _ Data Feature Extraction\nIn this section, we will create a new data frame called “node_data_feature” to consolidate the features obtained from previous analyses. This data frame will incorporate information regarding the nodes’ running_year_category, HScode_category, and company_label (wholesaler, supplier, or buyer), thereby enabling further subgrouping of the nodes based on these features.\n\n\nshow the code\nnode_data_feature <- node_data %>%\n  left_join(aggregate_data_HScode %>% distinct(company, HScode_category), by = c(\"ID\" = \"company\"))  %>%\n  left_join(aggregate_data_Year %>% distinct(company, running_year_category), by = c(\"ID\" = \"company\")) \n\nglimpse(node_data_feature)\n\n\nRows: 1,130\nColumns: 9\n$ ID                    <chr> \"1 Limited Liability Company\", \"1 Ltd. Liability…\n$ Betweenness           <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ In_Degree             <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ Out_Degree            <dbl> 1, 10, 12, 2, 3, 4, 1, 2, 9, 2, 21, 10, 5, 2, 1,…\n$ company_label         <chr> \"supplier_low\", \"supplier_low\", \"supplier_low\", …\n$ size_all              <dbl> 0.01063830, 0.10638298, 0.12765957, 0.02127660, …\n$ company_category      <chr> \"Supplier\", \"Supplier\", \"Supplier\", \"Supplier\", …\n$ HScode_category       <fct> <=1, >1, >1, >1, >1, >1, >1, >1, >1, <=1, <=1, >…\n$ running_year_category <fct> <=2, >2, >2, >2, >2, >2, >2, >2, >2, >2, >2, >2,…\n\n\n\n\nshow the code\n# Remove rows with NA values\n# <- node_data_feature[complete.cases(node_data_feature), ]\n\n# Create Company_group column and assign values based on conditions\nnode_data_feature$Company_group <- ifelse(\n  node_data_feature$running_year_category == \"<=2\" & node_data_feature$HScode_category == \"<=1\" & node_data_feature$company_category == \"Supplier\",\n  \"Unstable_Uniform_Supplier\",\n  ifelse(\n    node_data_feature$running_year_category == \"<=2\" & node_data_feature$HScode_category == \">1\" & node_data_feature$company_category == \"Supplier\",\n    \"Unstable_Diverse_Supplier\",\n    ifelse(\n      node_data_feature$running_year_category == \">2\" & node_data_feature$HScode_category == \"<=1\" & node_data_feature$company_category == \"Supplier\",\n      \"Stable_Uniform_Supplier\",\n      ifelse(\n        node_data_feature$running_year_category == \">2\" & node_data_feature$HScode_category == \">1\" & node_data_feature$company_category == \"Supplier\",\n        \"Stable_Diverse_Supplier\",\n        ifelse(\n          node_data_feature$running_year_category == \"<=2\" & node_data_feature$HScode_category == \"<=1\" & node_data_feature$company_category == \"Buyer\",\n          \"Unstable_Uniform_Buyer\",\n          ifelse(\n            node_data_feature$running_year_category == \"<=2\" & node_data_feature$HScode_category == \">1\" & node_data_feature$company_category == \"Buyer\",\n            \"Unstable_Diverse_Buyer\",\n            ifelse(\n              node_data_feature$running_year_category == \">2\" & node_data_feature$HScode_category == \"<=1\" & node_data_feature$company_category == \"Buyer\",\n              \"Stable_Uniform_Buyer\",\n              ifelse(\n                node_data_feature$running_year_category == \">2\" & node_data_feature$HScode_category == \">1\" & node_data_feature$company_category == \"Buyer\",\n                \"Stable_Diverse_Buyer\",\n                ifelse(\n                  node_data_feature$running_year_category == \"<=2\" & node_data_feature$HScode_category == \"<=1\" & node_data_feature$company_category == \"Wholesaler\",\n                  \"Unstable_Uniform_Wholesaler\",\n                  ifelse(\n                    node_data_feature$running_year_category == \"<=2\" & node_data_feature$HScode_category == \">1\" & node_data_feature$company_category == \"Wholesaler\",\n                    \"Unstable_Diverse_Wholesaler\",\n                    ifelse(\n                      node_data_feature$running_year_category == \">2\" & node_data_feature$HScode_category == \"<=1\" & node_data_feature$company_category == \"Wholesaler\",\n                      \"Stable_Uniform_Wholesaler\",\n                      ifelse(\n                        node_data_feature$running_year_category == \">2\" & node_data_feature$HScode_category == \">1\" & node_data_feature$company_category == \"Wholesaler\",\n                        \"Stable_Diverse_Wholesaler\",\n                        \"Unknown\"  # Handling unmatched situations can be changed according to actual needs\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n)\n\n\n\n\nshow the code\nlibrary(ggplot2)\n\n# Create a named vector that specifies the color corresponding to each group\ngroup_colors <- c(\"Unstable_Uniform_Supplier\" = \"red\",\n                  \"Unstable_Diverse_Supplier\" = \"blue\",\n                  \"Stable_Uniform_Supplier\" = \"green\",\n                  \"Stable_Diverse_Supplier\" = \"orange\",\n                  \"Unstable_Uniform_Buyer\" = \"purple\",\n                  \"Unstable_Diverse_Buyer\" = \"yellow\",\n                  \"Stable_Uniform_Buyer\" = \"pink\",\n                  \"Stable_Diverse_Buyer\" = \"brown\",\n                  \"Unstable_Uniform_Wholesaler\" = \"gray\",\n                  \"Unstable_Diverse_Wholesaler\" = \"cyan\",\n                  \"Stable_Uniform_Wholesaler\" = \"magenta\",\n                  \"Stable_Diverse_Wholesaler\" = \"Aquamarine\")\n\n# Count Company_ Number of groups per category\ngroup_counts <- table(node_data_feature$Company_group)\n\n# Convert count results into dataframe\ngroup_counts_df <- data.frame(Company_group = names(group_counts), Frequency = as.numeric(group_counts))\n\n# Draw a bar chart bfor the company group\nggplot(group_counts_df, aes(x = Company_group, y = Frequency, fill = Company_group)) +\n  geom_bar(stat = \"identity\") +\n  scale_fill_manual(values = group_colors) +\n  labs(x = \"Company Group\", y = \"Count\") +\n  ggtitle(\"Count of Company Groups\") +\n  theme_minimal() +\n  theme(plot.title = element_text(hjust = 0.5)) +\n  coord_flip()\n\n\n\n\n\nTo visualize the distribution of companies within these groups, a bar chart is plotted based on the company group. It is evident from the chart that the “Stable_Diverse_Supplier” group exhibits the highest percentage, followed by the “Stable_Diverse_Buyer” group. These two groups demonstrate noticeably higher percentages compared to the other groups, indicating their prominence within the network."
  },
  {
    "objectID": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#interactive-network-graph-with-visnetwork",
    "href": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#interactive-network-graph-with-visnetwork",
    "title": "Take-home_Ex02",
    "section": "3.1 Interactive Network Graph with visNetwork",
    "text": "3.1 Interactive Network Graph with visNetwork\nIn this section, a network plot is generated for a subset of nodes focusing on those with a specific HScode (306170). To manage the large volume of nodes, a filter condition based on the Year variable is applied, enabling the separation of networks for different years.\nIn the network plot, each node is assigned a color based on its company_group, allowing for a clear visualization of its distinctive features within the network. This coloring scheme facilitates the identification and interpretation of the nodes’ characteristics and facilitates the analysis of their interactions and connections.\n\n2028202920302031203220332034\n\n\n\n\nshow the code\n# Aggregating and filtering edges data\nmc2_edges_aggregated <- mc2_edges %>%\n  filter(hscode == \"306170\"& Year == \"2028\") %>%\n  group_by(from = source, to = target, hscode, Year) %>%\n  summarise(weights = n()) %>%\n  filter(from != to) %>%\n  filter(weights > 20) %>%\n  ungroup()\n\n# Extracting unique node IDs\nid1 <- mc2_edges_aggregated %>%\n  select(from) %>%\n  rename(id = from)\nid2 <- mc2_edges_aggregated %>%\n  select(to) %>%\n  rename(id = to)\nmc2_nodes_extracted <- rbind(id1, id2) %>%\n  distinct()\n\n# Joining extracted nodes with company data to add running_year_category information\nmc2_nodes_extracted <- mc2_nodes_extracted %>%\n  left_join(node_data_feature %>% distinct(ID, size_all, Company_group), by = c(\"id\" = \"ID\")) \n\nmc2_nodes_extracted <- mc2_nodes_extracted %>%\n  rename(group = Company_group)\n\n# Plot the network graph using visNetwork\ng <- visNetwork(nodes = mc2_nodes_extracted, edges = mc2_edges_aggregated,height = \"500px\", width = \"100%\") %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(size =50) %>%\n  visEdges(color = list(highlight = \"lightgray\")) %>%\n  visOptions(selectedBy = \"group\",\n             highlightNearest = list(enabled = TRUE,\n                                     degree = 1,\n                                     hover = TRUE,\n                                     labelOnly = TRUE),\n             nodesIdSelection = TRUE) %>%\n  visLegend() %>%\n  visInteraction(navigationButtons = TRUE) %>%\n  visLayout(randomSeed = 123)\n\ng"
  },
  {
    "objectID": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#ego-network-for-key-node",
    "href": "Take-home Exercise/Take-home Exercise 2/Take-home_Ex02.html#ego-network-for-key-node",
    "title": "Take-home_Ex02",
    "section": "3.2 Ego-Network for Key Node",
    "text": "3.2 Ego-Network for Key Node\nFor further analysis of key node connections, an ego-net approach is employed to examine the connections of a specific node, namely “hǎi dǎn Corporation Wharf,” which has been identified based on the previous section’s analysis. The selection of this node is driven by its numerous short-running year connections, suggesting potential significance and relevance in the network structure. By focusing on the ego-net of Hai Dan Corporation, we can gain deeper insights into its immediate connections and study its specific role and influence within the network.\n\n2028202920302031203220332034\n\n\n\n\nshow the code\n# Aggregating and filtering edges data\nmc2_edges_aggregated <- mc2_edges %>%\n  filter(hscode == \"306170\"& Year == \"2028\") %>%\n  group_by(from = source, to = target, hscode, Year) %>%\n  summarise(weights = n()) %>%\n  filter(from != to) %>%\n  filter(weights > 20) %>%\n  ungroup()\n\n# Extracting unique node IDs\nid1 <- mc2_edges_aggregated %>%\n  select(from) %>%\n  rename(id = from)\nid2 <- mc2_edges_aggregated %>%\n  select(to) %>%\n  rename(id = to)\nmc2_nodes_extracted <- rbind(id1, id2) %>%\n  distinct()\n\n# Joining extracted nodes with company data to add running_year_category information\nmc2_nodes_extracted <- mc2_nodes_extracted %>%\n  left_join(node_data_feature %>% distinct(ID, size_all, Company_group), by = c(\"id\" = \"ID\")) \n\nmc2_nodes_extracted <- mc2_nodes_extracted %>%\n  rename(group = Company_group)\n\n\nego_edges <- mc2_edges_aggregated %>%\n  filter(from == \"hǎi dǎn Corporation Wharf\" | to == \"hǎi dǎn Corporation Wharf\")\n\n# Extract unique node IDs from ego_edges\nego_node_ids <- unique(c(ego_edges$from, ego_edges$to))\n\n# Filter ego_nodes using the unique node IDs\nego_nodes <- mc2_nodes_extracted %>%\n  filter(id %in% ego_node_ids) %>%\n  mutate(node_id = row_number())\n\n# Update ego_edges with the corresponding node IDs\nego_edges <- ego_edges %>%\n  left_join(ego_nodes %>% select(id, node_id), by = c(\"from\" = \"id\")) %>%\n  rename(from_node = node_id) %>%\n  left_join(ego_nodes %>% select(id, node_id), by = c(\"to\" = \"id\")) %>%\n  rename(to_node = node_id)\n\n\nvisNetwork(nodes = ego_nodes, edges = ego_edges, height = \"500px\", width = \"100%\" ) %>%\n  visIgraphLayout(layout = \"layout_with_fr\") %>%\n  visNodes(size = 20) %>%\n  visEdges(color = \"gray\") %>%\nvisEdges(color = list(highlight = \"lightgray\")) %>%\n visOptions(selectedBy = \"group\",\n             highlightNearest = list(enabled = TRUE,\n                                     degree = 1,\n                                     hover = TRUE,\n                                     labelOnly = TRUE),\n             nodesIdSelection = TRUE) %>%\n  visLegend() %>%\n  visInteraction(navigationButtons = TRUE) %>%\n  visLayout(randomSeed = 123)   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFuture Work\nReference"
  }
]